<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Spear Tower Defense</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #game-container {
            display: flex;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #game-board {
            width: 600px;
            height: 400px;
            background-color: #8fbc8f;
            position: relative;
            overflow: hidden;
        }
        #sidebar {
            width: 200px;
            padding: 20px;
            background-color: #e0e0e0;
        }
        .cell {
            position: absolute;
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .plain { background-color: #8fbc8f; }
        .forest { background-color: #228B22; }
        .mountain { background-color: #A9A9A9; }
        .water { background-color: #1E90FF; }
        .wall { background-color: #8B4513; }
        .path {
            background-color: #d2b48c !important;
        }
        .tower {
            width: 30px;
            height: 30px;
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .ice-tower { background-color: #ADD8E6; }
        .fire-tower { background-color: #FF4500; }
        .stone-tower { background-color: #A9A9A9; }
        .wind-tower { background-color: #98FB98; }
        .enemy {
            width: 20px;
            height: 20px;
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            transition: left 0.1s linear, top 0.1s linear;
        }
        .goblin { background-color: #32cd32; }
        .orc { background-color: #8b0000; }
        .skeleton { background-color: #f0f0f0; }
        .slime { background-color: #00ff00; }
        .projectile {
            width: 6px;
            height: 6px;
            position: absolute;
            border-radius: 50%;
            background-color: #000;
            z-index: 15;
        }
        .damage-text {
            position: absolute;
            color: red;
            font-weight: bold;
            pointer-events: none;
            animation: fadeOut 0.5s forwards;
            z-index: 20;
        }
        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
        #error-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="error-display"></div>
    <div id="game-container">
        <div id="map-select">
        <button onclick="selectMap('plain')">平原マップ</button>
        <button onclick="selectMap('river')">川マップ</button>
        <button onclick="selectMap('mountain')">岩山マップ</button>
        </div>
        <div id="game-board"></div>
        <div id="sidebar">
            <h2>Ice Spear Tower Defense</h2>
            <div id="resources">
                <p>Gold: <span id="gold">300</span></p>
                <p>Mana: <span id="mana">50</span></p>
            </div>
            <div id="tower-buttons">
                <button onclick="selectTower('ice')">Ice Tower (50g)</button>
                <button onclick="selectTower('fire')">Fire Tower (100g)</button>
                <button onclick="selectTower('stone')">Stone Tower (150g)</button>
                <button onclick="selectTower('wind')">Wind Tower (150g)</button>
            </div>
            <div id="upgrades">
                <button onclick="upgrade('damage')">Upgrade Damage (100g)</button>
                <button onclick="upgrade('range')">Upgrade Range (100g)</button>
                <button onclick="upgrade('speed')">Upgrade Speed (100g)</button>
            </div>
            <p>Wave: <span id="wave">1</span></p>
            <p>Lives: <span id="lives">20</span></p>
            <button onclick="startWave()">Start Wave</button>
        </div>
    </div>

    <script>
        const gameBoard = document.getElementById('game-board');
        const goldDisplay = document.getElementById('gold');
        const manaDisplay = document.getElementById('mana');
        const waveDisplay = document.getElementById('wave');
        const livesDisplay = document.getElementById('lives');
        const errorDisplay = document.getElementById('error-display');

        let gold = 300;
        let mana = 50;
        let wave = 1;
        let lives = 20;
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let path = [];
        let selectedTower = null;
        let upgrades = { damage: 0, range: 0, speed: 0 };
        let totalEnemiesSpawned = 0;
        
        let isWaveInProgress = false;
        let waveEnemyCount = 0;

        const BOARD_WIDTH = 40;
        const BOARD_HEIGHT = 30;
        const cellWidth = 600 / BOARD_WIDTH;
        const cellHeight = 400 / BOARD_HEIGHT;       


        let grid = [];

        function initializeGrid() {
            grid = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
            let row = [];
            for (let x = 0; x < BOARD_WIDTH; x++) {
                row.push({
                x: x,
                y: y,
                type: 'plain', // 初期タイプ
                f: 0,
                g: 0,
                h: 0,
                parent: null,
                });
            }
            grid.push(row);
            }
        }

        // A* アルゴリズムの実装
        function findPath(startX, startY, endX, endY) {
            initializeGridForPathfinding(); // コストなどの初期化

            const startNode = grid[startY][startX];
            const endNode = grid[endY][endX];
            let openList = [];
            let closedList = [];

            openList.push(startNode);

            while (openList.length > 0) {
            // 最小コストのノードを選択
            let currentNode = openList[0];
            let currentIndex = 0;
            for (let i = 1; i < openList.length; i++) {
                if (openList[i].f < currentNode.f) {
                currentNode = openList[i];
                currentIndex = i;
                }
            }

            // openListから削除し、closedListに追加
            openList.splice(currentIndex, 1);
            closedList.push(currentNode);

            // ゴールに到達した場合
            if (currentNode === endNode) {
                return reconstructPath(currentNode); 
            }

            // 隣接ノードを調べる
            let neighbors = getNeighbors(currentNode);
            for (let neighbor of neighbors) {
                // 壁は無視
                if (neighbor.type === 'wall' || closedList.includes(neighbor)) {
                continue;
                }

                // コストを計算
                let tentativeGCost = currentNode.g + 1; // 仮のGコスト

                if (!openList.includes(neighbor) || tentativeGCost < neighbor.g) {
                neighbor.parent = currentNode;
                neighbor.g = tentativeGCost;
                neighbor.h = calculateHeuristic(neighbor, endNode); // ヒューリスティックコスト
                neighbor.f = neighbor.g + neighbor.h; // 合計コスト

                if (!openList.includes(neighbor)) {
                    openList.push(neighbor);
                }
                }
            }
            }
            return null; // ゴールへのパスが見つからない場合
        }

        function initializeGridForPathfinding() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                grid[y][x].f = 0;
                grid[y][x].g = 0;
                grid[y][x].h = 0;
                grid[y][x].parent = null;
            }
            }
        }

        function getNeighbors(node) {
            let neighbors = [];
            const { x, y } = node;
            if (x > 0) neighbors.push(grid[y][x - 1]); // 左
            if (x < BOARD_WIDTH - 1) neighbors.push(grid[y][x + 1]); // 右
            if (y > 0) neighbors.push(grid[y - 1][x]); // 上
            if (y < BOARD_HEIGHT - 1) neighbors.push(grid[y + 1][x]); // 下
            return neighbors;
        }

        function calculateHeuristic(nodeA, nodeB) {
            // マンハッタン距離をヒューリスティックとして使用
            return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
        }

        function reconstructPath(node) {
            let path = [];
            let currentNode = node;
            while (currentNode !== null) {
            path.unshift({ x: currentNode.x, y: currentNode.y }); 
            currentNode = currentNode.parent;
            }
                    return path; 
                }

        function showError(message) {
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 3000);
        }

        function createGameBoard() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.left = `${x * 40}px`;
                    cell.style.top = `${y * 40}px`;
                    cell.addEventListener('click', () => placeTower(x, y));
                    gameBoard.appendChild(cell);
                }
            }
            
            path = [
                {x: 0, y: 5}, {x: 1, y: 5}, {x: 2, y: 5}, {x: 3, y: 5},
                {x: 3, y: 4}, {x: 3, y: 3}, {x: 3, y: 2},
                {x: 4, y: 2}, {x: 5, y: 2}, {x: 6, y: 2}, {x: 7, y: 2},
                {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5}, {x: 7, y: 6},
                {x: 8, y: 6}, {x: 9, y: 6}, {x: 10, y: 6}, {x: 11, y: 6},
                {x: 11, y: 5}, {x: 11, y: 4}, {x: 11, y: 3},
                {x: 12, y: 3}, {x: 13, y: 3}, {x: 14, y: 3}
            ];
            
            path.forEach(p => {
                const pathCell = gameBoard.children[p.y * BOARD_WIDTH + p.x];
                pathCell.classList.add('path');
            });
        }

        function updateDisplays() {
            goldDisplay.textContent = gold;
            manaDisplay.textContent = mana;
            waveDisplay.textContent = wave;
            livesDisplay.textContent = lives;
        }

        function selectTower(type) {
            selectedTower = type;
        }

        function placeTower(x, y) {
            if (!selectedTower) return;
            
            const cost = { ice: 50, fire: 100, stone: 150, wind: 150 }[selectedTower];
            if (gold < cost) {
                showError("Not enough gold to place tower!");
                return;
            }
            
            if (grid[y][x] === 'path') {
                showError("Cannot place tower on the path!");
                return;
            }
            
            const cellWidth = 600 / BOARD_WIDTH;
            const cellHeight = 400 / BOARD_HEIGHT;
            
            const tower = document.createElement('div');
            tower.className = `tower ${selectedTower}-tower`;
            tower.style.left = `${x * cellWidth + cellWidth / 2}px`;
            tower.style.top = `${y * cellHeight + cellHeight / 2}px`;
            gameBoard.appendChild(tower);
            
            towers.push({ 
                x: x * cellWidth + cellWidth / 2, 
                y: y * cellHeight + cellHeight / 2, 
                type: selectedTower, 
                element: tower, 
                lastShot: 0,
                level: 1,
                damage: getTowerDamage(selectedTower, 1),
                range: getTowerRange(selectedTower, 1),
                fireRate: getTowerFireRate(selectedTower, 1)
            });
            gold -= cost;

            // 敵の移動ルートを再計算
            enemies.forEach(enemy => {
                enemy.path = findPath(0, 5, BOARD_WIDTH - 1, 5); // スタートとゴールは適宜変更
                enemy.pathIndex = 0; // ルート再計算後は、pathIndexをリセット
            });
            
            updateDisplays();
        }

        function getTowerDamage(type, level) {
            const baseDamage = { ice: 20, fire: 40, stone: 100, wind: 16 }[type];
            return baseDamage * (1 + 0.1 * (level - 1)) * (1 + upgrades.damage * 0.1);
        }

        function getTowerRange(type, level) {
            const baseRange = { ice: 80, fire: 80, stone: 50, wind: 160 }[type];
            return baseRange * (1 + 0.05 * (level - 1)) * (1 + upgrades.range * 0.1);
        }

        function getTowerFireRate(type, level) {
            const baseFireRate = { ice: 1, fire: 0.8, stone: 6, wind: 0.4 }[type];
            return baseFireRate * (1 - 0.05 * (level - 1)) * (1 - upgrades.speed * 0.1);
        }

        function createEnemy(type) {
            const enemy = document.createElement('div');
            const initialPosition = path[0];
            const initialX = initialPosition.x * cellWidth + cellWidth / 2;
            const initialY = initialPosition.y * cellHeight + cellHeight / 2;            
            enemy.className = `enemy ${type}`;
            gameBoard.appendChild(enemy);
            
            const health = { goblin: 40, orc: 115, skeleton: 30, slime: 120 }[type];
            const speed = { goblin: 0.02, orc: 0.01, skeleton: 0.04, slime: 0.006 }[type];
            
            enemies.push({ type, health, maxHealth: health, speed, path: findPath(0, 5, BOARD_WIDTH - 1, 5), // 敵ごとにパスを計算
                pathIndex: 0,
                element: enemy,
                x: initialX,
                y: initialY });
            totalEnemiesSpawned++;
        }

        function moveEnemies() {
            enemies.forEach((enemy, index) => {
                enemy.pathIndex += enemy.speed;
                
                if (!enemy.path || enemy.path.length === 0) {
                    enemy.path = findPath(0, 5, BOARD_WIDTH - 1, 5); // スタートとゴールを設定
                }

                if (enemy.pathIndex >= path.length - 1) {
                    gameBoard.removeChild(enemy.element);
                    enemies.splice(index, 1);
                    lives--;
                    updateDisplays();
                    return;
                } else {
                    let target = enemy.path[Math.ceil(enemy.pathIndex)]; // 次のターゲットセル
                    moveToTarget(enemy, target); // スムーズな移動処理
                } 
                
                /*
                const currentPos = path[Math.floor(enemy.pathIndex)];
                const nextPos = path[Math.min(Math.ceil(enemy.pathIndex), path.length - 1)];
                const progress = enemy.pathIndex - Math.floor(enemy.pathIndex);
                
                const x = currentPos.x * 40 + (nextPos.x - currentPos.x) * 40 * progress + 20;
                const y = currentPos.y * 40 + (nextPos.y - currentPos.y) * 40 * progress + 20;
                
                enemy.element.style.left = `${x}px`;
                enemy.element.style.top = `${y}px`;
                */
            });
        }

        function moveToTarget(enemy, target) {
            const cellWidth = 600 / BOARD_WIDTH;
            const cellHeight = 400 / BOARD_HEIGHT;
            const targetX = target.x * cellWidth + cellWidth / 2;
            const targetY = target.y * cellHeight + cellHeight / 2;
            const dx = targetX - parseInt(enemy.element.style.left);
            const dy = targetY - parseInt(enemy.element.style.top);
            const angle = Math.atan2(dy, dx);

            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { 
                enemy.element.style.left = `${parseInt(enemy.element.style.left) + enemy.speed * Math.cos(angle)}px`;
                enemy.element.style.top = `${parseInt(enemy.element.style.top) + enemy.speed * Math.sin(angle)}px`;
                enemy.pathIndex += enemy.speed;
            } else { 
                enemy.pathIndex++; // ターゲットセルに到達したら、次のセルへ
            }

            if (Math.abs(dx) > enemy.speed || Math.abs(dy) > enemy.speed) {
                // まだターゲットセルから離れている場合

                enemy.element.style.left = `${parseInt(enemy.element.style.left) + enemy.speed * Math.cos(angle)}px`;
                enemy.element.style.top = `${parseInt(enemy.element.style.top) + enemy.speed * Math.sin(angle)}px`;
                enemy.pathIndex += enemy.speed; // pathIndex を移動量に応じて更新
            } else {
                // ターゲットセルに到達した場合

                enemy.element.style.left = `${targetX}px`; // ターゲットセルの中心に移動
                enemy.element.style.top = `${targetY}px`;
                enemy.pathIndex++;
            }

        }        

        function shootEnemies() {
            towers.forEach(tower => {
                const now = Date.now();
                if (now - tower.lastShot > tower.fireRate * 1000) {
                    const target = enemies.find(enemy => {
                        const dx = parseInt(enemy.element.style.left) - tower.x;
                        const dy = parseInt(enemy.element.style.top) - tower.y;
                        return Math.sqrt(dx * dx + dy * dy) < tower.range;
                    });
                    
                    if (target) {
                        tower.lastShot = now;
                        
                        const projectile = document.createElement('div');
                        projectile.className = 'projectile';
                        projectile.style.left = `${tower.x}px`;
                        projectile.style.top = `${tower.y}px`;
                        gameBoard.appendChild(projectile);
                        
                        const targetX = parseInt(target.element.style.left);
                        const targetY = parseInt(target.element.style.top);
                        
                        projectiles.push({ element: projectile, x: tower.x, y: tower.y, targetX, targetY, damage: tower.damage, target, towerType: tower.type });
                    }
                }
            });
        }

        function moveProjectiles() {
            projectiles.forEach((projectile, index) => {
                const dx = projectile.targetX - projectile.x;
                const dy = projectile.targetY - projectile.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    gameBoard.removeChild(projectile.element);
                    projectiles.splice(index, 1);
                    
                    if (projectile.target && projectile.target.health) {
                        projectile.target.health -= projectile.damage;
                        showDamage(projectile.targetX, projectile.targetY, projectile.damage);
                        
                        applyTowerEffect(projectile.target, projectile.towerType);
                        
                        if (projectile.target.health <= 0) {
                            if (projectile.target.element && projectile.target.element.parentNode) {
                                gameBoard.removeChild(projectile.target.element);
                            }
                            enemies = enemies.filter(e => e !== projectile.target);
                            gold += getEnemyGoldReward(projectile.target.type);
                            updateDisplays();
                        }
                    }
                } else {
                    const speed = 5;
                    projectile.x += dx / distance * speed;
                    projectile.y += dy / distance * speed;
                    projectile.element.style.left = `${projectile.x}px`;
                    projectile.element.style.top = `${projectile.y}px`;
                }
            });
        }
        
        function showDamage(x, y, damage) {
            const damageText = document.createElement('div');
            damageText.className = 'damage-text';
            damageText.textContent = Math.round(damage);
            damageText.style.left = `${x}px`;
            damageText.style.top = `${y}px`;
            gameBoard.appendChild(damageText);
            
            setTimeout(() => {
                gameBoard.removeChild(damageText);
            }, 500);
        }

        function applyTowerEffect(enemy, towerType) {
            switch(towerType) {
                case 'ice':
                    enemy.speed *= 0.8;
                    setTimeout(() => { enemy.speed /= 0.8; }, 3000);
                    break;
                case 'fire':
                    setTimeout(() => {
                        enemy.health -= 5;
                        showDamage(parseInt(enemy.element.style.left), parseInt(enemy.element.style.top), 5);
                    }, 1000);
                    break;
                case 'stone':
                    if (Math.random() < 0.1) {
                        enemy.health = 0;
                    }
                    break;
                case 'wind':
                    const backIndex = Math.max(0, enemy.pathIndex - 1);
                    enemy.pathIndex = backIndex;
                    break;
            }
        }

        function getEnemyGoldReward(enemyType) {
            return { goblin: 10, orc: 20, skeleton: 15, slime: 15 }[enemyType];
        }

        function upgrade(type) {
            if (gold >= 100 && upgrades[type] < 5) {
                gold -= 100;
                upgrades[type]++;
                updateDisplays();
                towers.forEach(tower => {
                    tower.damage = getTowerDamage(tower.type, tower.level);
                    tower.range = getTowerRange(tower.type, tower.level);
                    tower.fireRate = getTowerFireRate(tower.type, tower.level);
                });
            } else {
                showError("Not enough gold or max upgrade reached!");
            }
        }

        function startWave() {
            if (isWaveInProgress) {
                showError("Wave already in progress!");
                return;
            }
            isWaveInProgress = true;
            waveEnemyCount = wave * 5;
            totalEnemiesSpawned = 0;
            
            let enemiesSpawned = 0;
            const spawnInterval = setInterval(() => {
                const types = ['goblin', 'orc', 'skeleton', 'slime'];
                createEnemy(types[Math.floor(Math.random() * types.length)]);
                enemiesSpawned++;
                if (enemiesSpawned >= waveEnemyCount) {
                    clearInterval(spawnInterval);
                }
            }, 2000 / wave);
        }
        
        function gameLoop() {
            moveEnemies();
            shootEnemies();
            moveProjectiles();
            if (lives <= 0) {
                showError('Game Over!');
                isWaveInProgress = false;
                return;
            }
            
            if (isWaveInProgress && enemies.length === 0 && totalEnemiesSpawned >= waveEnemyCount) {
                isWaveInProgress = false;
                gold += 50;
                wave++;
                updateDisplays();
                showError('Wave Cleared! +50 gold');
                console.log(`Wave cleared. Total enemies spawned: ${totalEnemiesSpawned}, Wave enemy count: ${waveEnemyCount}`);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        initializeMap('plain');
        updateDisplays();
        gameLoop();

        function selectMap(mapType) {
            initializeMap(mapType);
            resetGameState();
        }

        function handleCellClick(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);
            placeTower(x, y);
        }

        function initializeMap(mapType) {
            grid = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                let row = [];
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (x === 0 || x === BOARD_WIDTH - 1 || y === 0 || y === BOARD_HEIGHT - 1) {
                        row.push('wall');
                    } else {
                        row.push('plain');
                    }
                }
                grid.push(row);
            }

            switch (mapType) {
                case 'plain':
                    addRandomTerrain('forest', 0.1);
                    break;
                case 'river':
                    generateRiver();
                    addRandomTerrain('forest', 0.05);
                    break;
                case 'mountain':
                    addRandomTerrain('mountain', 0.2);
                    break;
            }

            // パスの生成
            path = generatePath();

            renderMap();
            console.log(`Initialized ${mapType} map`);
            initializeGrid();
        }

        function generatePath() {
            let path = [];
            let x = 0;
            let y = Math.floor(BOARD_HEIGHT / 2);
            while (x < BOARD_WIDTH) {
                path.push({x, y});
                grid[y][x] = 'path';
                if (Math.random() < 0.3) {
                    if (Math.random() < 0.5 && y > 1) {
                        y--;
                    } else if (y < BOARD_HEIGHT - 2) {
                        y++;
                    }
                }
                x++;
            }
            return path;
        }

        function addRandomTerrain(terrainType, probability) {
            for (let y = 1; y < BOARD_HEIGHT - 1; y++) {
                for (let x = 1; x < BOARD_WIDTH - 1; x++) {
                    if (Math.random() < probability) {
                        grid[y][x] = terrainType;
                    }
                }
            }
        }

        function generateRiver() {
            let x = 0;
            let y = Math.floor(BOARD_HEIGHT / 2);
            while (x < BOARD_WIDTH) {
                grid[y][x] = 'water';
                if (Math.random() < 0.3) {
                    y += Math.random() < 0.5 ? 1 : -1;
                    y = Math.max(1, Math.min(y, BOARD_HEIGHT - 2));
                }
                x++;
            }
            // 橋を追加
            for (let i = 0; i < 3; i++) {
                let bridgeX = Math.floor(Math.random() * (BOARD_WIDTH - 2)) + 1;
                for (let bridgeY = 0; bridgeY < BOARD_HEIGHT; bridgeY++) {
                    if (grid[bridgeY][bridgeX] === 'water') {
                        grid[bridgeY][bridgeX] = 'plain';
                    }
                }
            }
        }

        function renderMap() {
            gameBoard.innerHTML = '';
            const cellWidth = 600 / BOARD_WIDTH;
            const cellHeight = 400 / BOARD_HEIGHT;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell', grid[y][x]);
                    cell.style.left = `${x * cellWidth}px`;
                    cell.style.top = `${y * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', handleCellClick);
                    gameBoard.appendChild(cell);
                }
            }
        }

        function resetGameState() {
            // ゲーム状態をリセット
            enemies = [];
            towers = [];
            gold = 300;
            mana = 50;
            wave = 1;
            lives = 20;
            
            // UI更新
            document.getElementById('gold').textContent = gold;
            document.getElementById('mana').textContent = mana;
            document.getElementById('wave').textContent = wave;
            document.getElementById('lives').textContent = lives;
        }


    </script>
</body>
</html>
