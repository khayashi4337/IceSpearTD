<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ice Spear Tower Defense</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #game-container {
            display: flex;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #game-board {
            width: 600px;
            height: 400px;
            background-color: #8fbc8f;
            position: relative;
            overflow: hidden;
        }
        #sidebar {
            width: 200px;
            padding: 20px;
            background-color: #e0e0e0;
        }
        .cell {
            position: absolute;
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .plain { background-color: #8fbc8f; }
        .forest { background-color: #228B22; }
        .mountain { background-color: #A9A9A9; }
        .water { background-color: #1E90FF; }
        .wall { background-color: #8B4513; }
        .path {
            background-color: #d2b48c !important;
        }
        .tower {
            width: 30px;
            height: 30px;
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .ice-tower { background-color: #ADD8E6; }
        .fire-tower { background-color: #FF4500; }
        .stone-tower { background-color: #A9A9A9; }
        .wind-tower { background-color: #98FB98; }
        .enemy {
            width: 20px;
            height: 20px;
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            transition: left 0.1s linear, top 0.1s linear;
        }
        .goblin { background-color: #32cd32; }
        .orc { background-color: #8b0000; }
        .skeleton { background-color: #f0f0f0; }
        .slime { background-color: #00ff00; }
        .projectile {
            width: 6px;
            height: 6px;
            position: absolute;
            border-radius: 50%;
            background-color: #000;
            z-index: 15;
        }
        .damage-text {
            position: absolute;
            color: red;
            font-weight: bold;
            pointer-events: none;
            animation: fadeOut 0.5s forwards;
            z-index: 20;
        }
        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
        #error-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="error-display"></div>
    <div id="game-container">
        <div id="map-select">
        <button onclick="selectMap('plain')">平原マップ</button>
        <button onclick="selectMap('river')">川マップ</button>
        <button onclick="selectMap('mountain')">岩山マップ</button>
        </div>
        <div id="game-board"></div>
        <div id="sidebar">
            <h2>Ice Spear Tower Defense</h2>
            <div id="resources">
                <p>Gold: <span id="gold">300</span></p>
                <p>Mana: <span id="mana">50</span></p>
            </div>
            <div id="tower-buttons">
                <button onclick="selectTower('ice')">Ice Tower (50g)</button>
                <button onclick="selectTower('fire')">Fire Tower (100g)</button>
                <button onclick="selectTower('stone')">Stone Tower (150g)</button>
                <button onclick="selectTower('wind')">Wind Tower (150g)</button>
            </div>
            <div id="upgrades">
                <button onclick="upgrade('damage')">Upgrade Damage (100g)</button>
                <button onclick="upgrade('range')">Upgrade Range (100g)</button>
                <button onclick="upgrade('speed')">Upgrade Speed (100g)</button>
            </div>
            <p>Wave: <span id="wave">1</span></p>
            <p>Lives: <span id="lives">20</span></p>
            <button onclick="startWave()">Start Wave</button>
        </div>
    </div>

    <script>
        const gameBoard = document.getElementById('game-board');
        const goldDisplay = document.getElementById('gold');
        const manaDisplay = document.getElementById('mana');
        const waveDisplay = document.getElementById('wave');
        const livesDisplay = document.getElementById('lives');
        const errorDisplay = document.getElementById('error-display');

        let gold = 300;
        let mana = 50;
        let wave = 1;
        let lives = 20;
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let path = [];
        let selectedTower = null;
        let upgrades = { damage: 0, range: 0, speed: 0 };
        let totalEnemiesSpawned = 0;
        
        let isWaveInProgress = false;
        let waveEnemyCount = 0;

        const BOARD_WIDTH = 40;
        const BOARD_HEIGHT = 30;
        const cellWidth = 600 / BOARD_WIDTH;
        const cellHeight = 400 / BOARD_HEIGHT;       


        let grid = [];

        function initializeGrid() {
            grid = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
            let row = [];
            for (let x = 0; x < BOARD_WIDTH; x++) {
                row.push({
                x: x,
                y: y,
                type: 'plain', // 初期タイプ
                f: 0,
                g: 0,
                h: 0,
                parent: null,
                });
            }
            grid.push(row);
            }
        }

        /**
        * A*アルゴリズムを使用して最短経路を見つける関数
        * @param {number} startX - 開始地点のX座標
        * @param {number} startY - 開始地点のY座標
        * @param {number} endX - 目標地点のX座標
        * @param {number} endY - 目標地点のY座標
        * @returns {Array} 最短経路の座標配列
        */
        function findPath(startX, startY, endX, endY) {
            // パス探索のためにグリッドを初期化
            initializeGridForPathfinding();

            const startNode = grid[startY][startX];
            const endNode = grid[endY][endX];
            let openList = [];
            let closedList = [];

            openList.push(startNode);

            while (openList.length > 0) {
                // オープンリストから最小のfスコアを持つノードを見つける
                let currentNode = openList.reduce((min, node) => node.f < min.f ? node : min, openList[0]);
                let currentIndex = openList.indexOf(currentNode);

                // 現在のノードをオープンリストから削除し、クローズドリストに追加
                openList.splice(currentIndex, 1);
                closedList.push(currentNode);

                // 目標に到達した場合、パスを再構築して返す
                if (currentNode === endNode) {
                    let path = [];
                    let current = currentNode;
                    while (current !== null) {
                        path.push({x: current.x, y: current.y});
                        current = current.parent;
                    }
                    return path.reverse();
                }

                // 隣接するノードをチェック
                let neighbors = getNeighbors(currentNode);
                for (let neighbor of neighbors) {
                    if (closedList.includes(neighbor)) {
                        continue;  // すでに評価済みのノードはスキップ
                    }

                    let tentativeGScore = currentNode.g + 1;  // 隣接ノードへの移動コストを1と仮定

                    if (!openList.includes(neighbor)) {
                        // 新しいノードをオープンリストに追加
                        openList.push(neighbor);
                    } else if (tentativeGScore >= neighbor.g) {
                        continue;  // このパスは良くない
                    }

                    // このパスが最良なので記録する
                    neighbor.parent = currentNode;
                    neighbor.g = tentativeGScore;
                    neighbor.h = calculateHeuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                }
            }

            return [];  // パスが見つからない場合
        }


        /**
        * パス探索のためにグリッドを初期化する関数
        */
        function initializeGridForPathfinding() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    grid[y][x].f = 0;
                    grid[y][x].g = 0;
                    grid[y][x].h = 0;
                    grid[y][x].parent = null;
                }
            }
        }


        /**
        * 指定されたノードの隣接ノードを取得する関数
        * @param {Object} node - 現在のノード
        * @returns {Array} 隣接ノードの配列
        */
        function getNeighbors(node) {
            let neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];  // 上、右、下、左
            for (let [dx, dy] of directions) {
                let newX = node.x + dx;
                let newY = node.y + dy;
                if (newX >= 0 && newX < BOARD_WIDTH && newY >= 0 && newY < BOARD_HEIGHT) {
                    if (grid[newY][newX].type !== 'wall') {
                        neighbors.push(grid[newY][newX]);
                    }
                }
            }
            return neighbors;
        }

        /**
        * 二点間のマンハッタン距離を計算するヒューリスティック関数
        * @param {Object} nodeA - 開始ノード
        * @param {Object} nodeB - 目標ノード
        * @returns {number} 推定距離
        */
        function calculateHeuristic(nodeA, nodeB) {
            return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
        }

        function reconstructPath(node) {
            let path = [];
            let currentNode = node;
            while (currentNode !== null) {
            path.unshift({ x: currentNode.x, y: currentNode.y }); 
            currentNode = currentNode.parent;
            }
                    return path; 
                }

        function showError(message) {
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 3000);
        }

        function createGameBoard() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.left = `${x * 40}px`;
                    cell.style.top = `${y * 40}px`;
                    cell.addEventListener('click', () => placeTower(x, y));
                    gameBoard.appendChild(cell);
                }
            }
            
            path = [
                {x: 0, y: 5}, {x: 1, y: 5}, {x: 2, y: 5}, {x: 3, y: 5},
                {x: 3, y: 4}, {x: 3, y: 3}, {x: 3, y: 2},
                {x: 4, y: 2}, {x: 5, y: 2}, {x: 6, y: 2}, {x: 7, y: 2},
                {x: 7, y: 3}, {x: 7, y: 4}, {x: 7, y: 5}, {x: 7, y: 6},
                {x: 8, y: 6}, {x: 9, y: 6}, {x: 10, y: 6}, {x: 11, y: 6},
                {x: 11, y: 5}, {x: 11, y: 4}, {x: 11, y: 3},
                {x: 12, y: 3}, {x: 13, y: 3}, {x: 14, y: 3}
            ];
            
            path.forEach(p => {
                const pathCell = gameBoard.children[p.y * BOARD_WIDTH + p.x];
                pathCell.classList.add('path');
            });
        }

        function updateDisplays() {
            goldDisplay.textContent = gold;
            manaDisplay.textContent = mana;
            waveDisplay.textContent = wave;
            livesDisplay.textContent = lives;
        }

        function selectTower(type) {
            selectedTower = type;
        }

        /**
        * タワーを配置する関数
        * @param {number} x - 配置するX座標
        * @param {number} y - 配置するY座標
        */
        function placeTower(x, y) {
            if (!selectedTower) return;
            
            const towerCost = { ice: 50, fire: 100, stone: 150, wind: 150 }[selectedTower];
            if (gold < towerCost) {
                showError("Not enough gold to place tower!");
                return;
            }
            
            if (grid[y][x].type === 'path' || grid[y][x].type === 'wall') {
                showError("Cannot place tower here!");
                return;
            }
            
            // タワーの視覚要素を作成
            const towerElement = document.createElement('div');
            towerElement.className = `tower ${selectedTower}-tower`;
            towerElement.style.left = `${x * cellWidth + cellWidth / 2}px`;
            towerElement.style.top = `${y * cellHeight + cellHeight / 2}px`;
            towerElement.style.width = `${cellWidth * 0.8}px`;
            towerElement.style.height = `${cellHeight * 0.8}px`;
            gameBoard.appendChild(towerElement);
            
            // タワーオブジェクトを作成し、配列に追加
            towers.push({ 
                x: x * cellWidth + cellWidth / 2, 
                y: y * cellHeight + cellHeight / 2, 
                type: selectedTower, 
                element: towerElement, 
                lastShot: 0,
                level: 1,
                damage: getTowerDamage(selectedTower, 1),
                range: getTowerRange(selectedTower, 1),
                fireRate: getTowerFireRate(selectedTower, 1)
            });
            
            gold -= towerCost;
            updateDisplays();
        }


        function getTowerDamage(type, level) {
            const baseDamage = { ice: 20, fire: 40, stone: 100, wind: 16 }[type];
            return baseDamage * (1 + 0.1 * (level - 1)) * (1 + upgrades.damage * 0.1);
        }

        function getTowerRange(type, level) {
            const baseRange = { ice: 80, fire: 80, stone: 50, wind: 160 }[type];
            return baseRange * (1 + 0.05 * (level - 1)) * (1 + upgrades.range * 0.1);
        }

        function getTowerFireRate(type, level) {
            const baseFireRate = { ice: 1, fire: 0.8, stone: 6, wind: 0.4 }[type];
            return baseFireRate * (1 - 0.05 * (level - 1)) * (1 - upgrades.speed * 0.1);
        }



        /**
        * 敵キャラクターを移動させる関数
        */
        function moveEnemies() {
            enemies.forEach((enemy, index) => {
                // 敵がパスの終点に到達した場合
                if (enemy.pathIndex >= enemy.path.length) {
                    gameBoard.removeChild(enemy.element);
                    enemies.splice(index, 1);
                    lives--;
                    updateDisplays();
                    return;
                }

                // 次の目標位置を取得
                let targetPosition = enemy.path[enemy.pathIndex];
                let targetX = targetPosition.x * cellWidth + cellWidth / 2;
                let targetY = targetPosition.y * cellHeight + cellHeight / 2;

                // 現在位置と目標位置の差分を計算
                let deltaX = targetX - enemy.x;
                let deltaY = targetY - enemy.y;
                let distanceToTarget = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // 目標位置に到達したら、次の位置へ
                if (distanceToTarget < enemy.speed) {
                    enemy.pathIndex++;
                    enemy.x = targetX;
                    enemy.y = targetY;
                } else {
                    // 目標位置に向かって移動
                    let movementRatio = enemy.speed / distanceToTarget;
                    enemy.x += deltaX * movementRatio;
                    enemy.y += deltaY * movementRatio;
                }

                // 敵の位置を更新
                enemy.element.style.left = `${enemy.x}px`;
                enemy.element.style.top = `${enemy.y}px`;
            });
        }


        // ゲームループの実装
        function gameLoop() {
            moveEnemies();
            shootEnemies();
            moveProjectiles();

            if (lives <= 0) {
                showError('Game Over!');
                isWaveInProgress = false;
                return;
            }

            if (isWaveInProgress && enemies.length === 0 && totalEnemiesSpawned >= waveEnemyCount) {
                isWaveInProgress = false;
                gold += 50;
                wave++;
                updateDisplays();
                showError('Wave Cleared! +50 gold');
            }

            requestAnimationFrame(gameLoop);
        }
        

        /**
        * 新しい敵キャラクターを作成する関数
        * @param {string} enemyType - 敵の種類
        */
        function createEnemy(enemyType) {
            const startPosition = path[0];
            const enemyElement = document.createElement('div');
            enemyElement.className = `enemy ${enemyType}`;
            enemyElement.style.left = `${startPosition.x * cellWidth + cellWidth / 2}px`;
            enemyElement.style.top = `${startPosition.y * cellHeight + cellHeight / 2}px`;
            enemyElement.style.width = `${cellWidth * 0.6}px`;
            enemyElement.style.height = `${cellHeight * 0.6}px`;
            gameBoard.appendChild(enemyElement);

            const enemyHealth = { goblin: 40, orc: 115, skeleton: 30, slime: 120 }[enemyType];
            const enemySpeed = { goblin: 1, orc: 0.5, skeleton: 2, slime: 0.3 }[enemyType];

            enemies.push({
                type: enemyType,
                health: enemyHealth,
                maxHealth: enemyHealth,
                speed: enemySpeed,
                path: findPath(startPosition.x, startPosition.y, BOARD_WIDTH - 1, Math.floor(BOARD_HEIGHT / 2)),
                pathIndex: 0,
                element: enemyElement,
                x: startPosition.x * cellWidth + cellWidth / 2,
                y: startPosition.y * cellHeight + cellHeight / 2
            });
            totalEnemiesSpawned++;
        }  


        function moveToTarget(enemy, target) {
            const cellWidth = 600 / BOARD_WIDTH;
            const cellHeight = 400 / BOARD_HEIGHT;
            const targetX = target.x * cellWidth + cellWidth / 2;
            const targetY = target.y * cellHeight + cellHeight / 2;
            const dx = targetX - parseInt(enemy.element.style.left);
            const dy = targetY - parseInt(enemy.element.style.top);
            const angle = Math.atan2(dy, dx);

            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) { 
                enemy.element.style.left = `${parseInt(enemy.element.style.left) + enemy.speed * Math.cos(angle)}px`;
                enemy.element.style.top = `${parseInt(enemy.element.style.top) + enemy.speed * Math.sin(angle)}px`;
                enemy.pathIndex += enemy.speed;
            } else { 
                enemy.pathIndex++; // ターゲットセルに到達したら、次のセルへ
            }

            if (Math.abs(dx) > enemy.speed || Math.abs(dy) > enemy.speed) {
                // まだターゲットセルから離れている場合

                enemy.element.style.left = `${parseInt(enemy.element.style.left) + enemy.speed * Math.cos(angle)}px`;
                enemy.element.style.top = `${parseInt(enemy.element.style.top) + enemy.speed * Math.sin(angle)}px`;
                enemy.pathIndex += enemy.speed; // pathIndex を移動量に応じて更新
            } else {
                // ターゲットセルに到達した場合

                enemy.element.style.left = `${targetX}px`; // ターゲットセルの中心に移動
                enemy.element.style.top = `${targetY}px`;
                enemy.pathIndex++;
            }

        }        

        function shootEnemies() {
            towers.forEach(tower => {
                const now = Date.now();
                if (now - tower.lastShot > tower.fireRate * 1000) {
                    const target = enemies.find(enemy => {
                        const dx = parseInt(enemy.element.style.left) - tower.x;
                        const dy = parseInt(enemy.element.style.top) - tower.y;
                        return Math.sqrt(dx * dx + dy * dy) < tower.range;
                    });
                    
                    if (target) {
                        tower.lastShot = now;
                        
                        const projectile = document.createElement('div');
                        projectile.className = 'projectile';
                        projectile.style.left = `${tower.x}px`;
                        projectile.style.top = `${tower.y}px`;
                        gameBoard.appendChild(projectile);
                        
                        const targetX = parseInt(target.element.style.left);
                        const targetY = parseInt(target.element.style.top);
                        
                        projectiles.push({ element: projectile, x: tower.x, y: tower.y, targetX, targetY, damage: tower.damage, target, towerType: tower.type });
                    }
                }
            });
        }

        function moveProjectiles() {
            projectiles.forEach((projectile, index) => {
                const dx = projectile.targetX - projectile.x;
                const dy = projectile.targetY - projectile.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    gameBoard.removeChild(projectile.element);
                    projectiles.splice(index, 1);
                    
                    if (projectile.target && projectile.target.health) {
                        projectile.target.health -= projectile.damage;
                        showDamage(projectile.targetX, projectile.targetY, projectile.damage);
                        
                        applyTowerEffect(projectile.target, projectile.towerType);
                        
                        if (projectile.target.health <= 0) {
                            if (projectile.target.element && projectile.target.element.parentNode) {
                                gameBoard.removeChild(projectile.target.element);
                            }
                            enemies = enemies.filter(e => e !== projectile.target);
                            gold += getEnemyGoldReward(projectile.target.type);
                            updateDisplays();
                        }
                    }
                } else {
                    const speed = 5;
                    projectile.x += dx / distance * speed;
                    projectile.y += dy / distance * speed;
                    projectile.element.style.left = `${projectile.x}px`;
                    projectile.element.style.top = `${projectile.y}px`;
                }
            });
        }
        
        function showDamage(x, y, damage) {
            const damageText = document.createElement('div');
            damageText.className = 'damage-text';
            damageText.textContent = Math.round(damage);
            damageText.style.left = `${x}px`;
            damageText.style.top = `${y}px`;
            gameBoard.appendChild(damageText);
            
            setTimeout(() => {
                gameBoard.removeChild(damageText);
            }, 500);
        }

        function applyTowerEffect(enemy, towerType) {
            switch(towerType) {
                case 'ice':
                    enemy.speed *= 0.8;
                    setTimeout(() => { enemy.speed /= 0.8; }, 3000);
                    break;
                case 'fire':
                    setTimeout(() => {
                        enemy.health -= 5;
                        showDamage(parseInt(enemy.element.style.left), parseInt(enemy.element.style.top), 5);
                    }, 1000);
                    break;
                case 'stone':
                    if (Math.random() < 0.1) {
                        enemy.health = 0;
                    }
                    break;
                case 'wind':
                    const backIndex = Math.max(0, enemy.pathIndex - 1);
                    enemy.pathIndex = backIndex;
                    break;
            }
        }

        function getEnemyGoldReward(enemyType) {
            return { goblin: 10, orc: 20, skeleton: 15, slime: 15 }[enemyType];
        }

        function upgrade(type) {
            if (gold >= 100 && upgrades[type] < 5) {
                gold -= 100;
                upgrades[type]++;
                updateDisplays();
                towers.forEach(tower => {
                    tower.damage = getTowerDamage(tower.type, tower.level);
                    tower.range = getTowerRange(tower.type, tower.level);
                    tower.fireRate = getTowerFireRate(tower.type, tower.level);
                });
            } else {
                showError("Not enough gold or max upgrade reached!");
            }
        }

        function startWave() {
            if (isWaveInProgress) {
                showError("Wave already in progress!");
                return;
            }
            isWaveInProgress = true;
            waveEnemyCount = wave * 5;
            totalEnemiesSpawned = 0;
            
            let enemiesSpawned = 0;
            const spawnInterval = setInterval(() => {
                const types = ['goblin', 'orc', 'skeleton', 'slime'];
                createEnemy(types[Math.floor(Math.random() * types.length)]);
                enemiesSpawned++;
                if (enemiesSpawned >= waveEnemyCount) {
                    clearInterval(spawnInterval);
                }
            }, 2000 / wave);
        }
        
        initializeMap('plain');
        updateDisplays();
        gameLoop();

        function selectMap(mapType) {
            initializeMap(mapType);
            resetGameState();
        }

        function handleCellClick(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);
            placeTower(x, y);
        }

        function initializeMap(mapType) {
            grid = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                let row = [];
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (x === 0 || x === BOARD_WIDTH - 1 || y === 0 || y === BOARD_HEIGHT - 1) {
                        row.push('wall');
                    } else {
                        row.push('plain');
                    }
                }
                grid.push(row);
            }

            switch (mapType) {
                case 'plain':
                    addRandomTerrain('forest', 0.1);
                    break;
                case 'river':
                    generateRiver();
                    addRandomTerrain('forest', 0.05);
                    break;
                case 'mountain':
                    addRandomTerrain('mountain', 0.2);
                    break;
            }

            // パスの生成
            path = generatePath();

            renderMap();
            console.log(`Initialized ${mapType} map`);
            initializeGrid();

            // ゲームループを開始
            requestAnimationFrame(gameLoop);
        }

        function generatePath() {
            let path = [];
            let x = 0;
            let y = Math.floor(BOARD_HEIGHT / 2);
            while (x < BOARD_WIDTH) {
                path.push({x, y});
                grid[y][x] = 'path';
                if (Math.random() < 0.3) {
                    if (Math.random() < 0.5 && y > 1) {
                        y--;
                    } else if (y < BOARD_HEIGHT - 2) {
                        y++;
                    }
                }
                x++;
            }
            return path;
        }

        function addRandomTerrain(terrainType, probability) {
            for (let y = 1; y < BOARD_HEIGHT - 1; y++) {
                for (let x = 1; x < BOARD_WIDTH - 1; x++) {
                    if (Math.random() < probability) {
                        grid[y][x] = terrainType;
                    }
                }
            }
        }

        function generateRiver() {
            let x = 0;
            let y = Math.floor(BOARD_HEIGHT / 2);
            while (x < BOARD_WIDTH) {
                grid[y][x] = 'water';
                if (Math.random() < 0.3) {
                    y += Math.random() < 0.5 ? 1 : -1;
                    y = Math.max(1, Math.min(y, BOARD_HEIGHT - 2));
                }
                x++;
            }
            // 橋を追加
            for (let i = 0; i < 3; i++) {
                let bridgeX = Math.floor(Math.random() * (BOARD_WIDTH - 2)) + 1;
                for (let bridgeY = 0; bridgeY < BOARD_HEIGHT; bridgeY++) {
                    if (grid[bridgeY][bridgeX] === 'water') {
                        grid[bridgeY][bridgeX] = 'plain';
                    }
                }
            }
        }

        function renderMap() {
            gameBoard.innerHTML = '';
            const cellWidth = 600 / BOARD_WIDTH;
            const cellHeight = 400 / BOARD_HEIGHT;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell', grid[y][x]);
                    cell.style.left = `${x * cellWidth}px`;
                    cell.style.top = `${y * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', handleCellClick);
                    gameBoard.appendChild(cell);
                }
            }
        }

        function resetGameState() {
            // ゲーム状態をリセット
            enemies = [];
            towers = [];
            gold = 300;
            mana = 50;
            wave = 1;
            lives = 20;
            
            // UI更新
            document.getElementById('gold').textContent = gold;
            document.getElementById('mana').textContent = mana;
            document.getElementById('wave').textContent = wave;
            document.getElementById('lives').textContent = lives;
        }
        
        // ゲームの初期化
        initializeMap('plain');
        updateDisplays();

    </script>
</body>
</html>
