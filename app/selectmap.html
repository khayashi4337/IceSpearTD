<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>複雑なタワーディフェンスゲーム</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-board {
            position: relative;
            width: 800px;
            height: 600px;
            display: grid;
            grid-template-columns: repeat(40, 1fr);
            grid-template-rows: repeat(30, 1fr);
            gap: 1px;
            background-color: #000;
            overflow: hidden;
        }
        .cell {
            position: relative;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        .plain { background-color: #8B4513; }
        .forest { background-color: #228B22; }
        .mountain { background-color: #A9A9A9; }
        .water { background-color: #1E90FF; }
        .wall { background-color: #8B4513; }
        .tower-base { background-color: #4169E1; }
        .enemy {
            position: absolute;
            width: 2.5%; /* 100 / GRID_WIDTH */
            height: 3.33%; /* 100 / GRID_HEIGHT */
            border-radius: 50%;
            background-color: red;
            transition: all 0.5s;
            transform: translate(-50%, -50%);
        }
        .tower {
            width: 80%;
            height: 80%;
            background-color: #1E90FF;
            border-radius: 10%;
            position: relative;
            top: 10%;
            left: 10%;
        }
        #controls, #map-select {
            margin-top: 20px;
        }
        button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 16px;
        }
        #stats {
            margin-top: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="map-select">
            <button id="plain-map">平原マップ</button>
            <button id="river-map">川マップ</button>
            <button id="mountain-map">岩山マップ</button>
        </div>
        <div id="game-board"></div>
        <div id="controls">
            <button id="start-wave">ウェーブ開始</button>
            <button id="add-tower">タワー追加</button>
        </div>
        <div id="stats">
            <p>プレイヤーの体力: <span id="player-health">100</span></p>
            <p>ウェーブ: <span id="wave-counter">0</span></p>
            <p>残り時間: <span id="wave-timer">60</span>秒</p>
        </div>
    </div>
    <script>
const gameBoard = document.getElementById('game-board');
const startWaveButton = document.getElementById('start-wave');
const addTowerButton = document.getElementById('add-tower');
const playerHealthDisplay = document.getElementById('player-health');
const waveCounterDisplay = document.getElementById('wave-counter');
const waveTimerDisplay = document.getElementById('wave-timer');

const GRID_WIDTH = 40;
const GRID_HEIGHT = 30;
let grid = [];
let enemies = [];
let towers = [];
let playerHealth = 100;
let isPlacingTower = false;
let currentWave = 0;
let waveTimer = 60;
let waveInterval;

const terrainTypes = {
    plain: { color: '#8B4513', speedMultiplier: 1 },
    forest: { color: '#228B22', speedMultiplier: 0.7 },
    mountain: { color: '#A9A9A9', speedMultiplier: 0.5 },
    water: { color: '#1E90FF', speedMultiplier: 0 },
    wall: { color: '#8B4513', speedMultiplier: 0 }
};

function initializeMap(mapType) {
    grid = [];
    for (let y = 0; y < GRID_HEIGHT; y++) {
        let row = [];
        for (let x = 0; x < GRID_WIDTH; x++) {
            if (x === 0 || x === GRID_WIDTH - 1 || y === 0 || y === GRID_HEIGHT - 1) {
                row.push('wall');
            } else {
                row.push('plain');
            }
        }
        grid.push(row);
    }

    // マップタイプに応じた地形生成
    switch (mapType) {
        case 'plain':
            addRandomTerrain('forest', 0.1);
            break;
        case 'river':
            generateRiver();
            addRandomTerrain('forest', 0.05);
            break;
        case 'mountain':
            addRandomTerrain('mountain', 0.2);
            break;
    }

    renderMap();
}

function addRandomTerrain(terrainType, probability) {
    for (let y = 1; y < GRID_HEIGHT - 1; y++) {
        for (let x = 1; x < GRID_WIDTH - 1; x++) {
            if (Math.random() < probability) {
                grid[y][x] = terrainType;
            }
        }
    }
}

function generateRiver() {
    let x = 0;
    let y = Math.floor(GRID_HEIGHT / 2);
    while (x < GRID_WIDTH) {
        grid[y][x] = 'water';
        if (Math.random() < 0.3) {
            y += Math.random() < 0.5 ? 1 : -1;
            y = Math.max(1, Math.min(y, GRID_HEIGHT - 2));
        }
        x++;
    }
    // 橋を追加
    for (let i = 0; i < 3; i++) {
        let bridgeX = Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1;
        for (let bridgeY = 0; bridgeY < GRID_HEIGHT; bridgeY++) {
            if (grid[bridgeY][bridgeX] === 'water') {
                grid[bridgeY][bridgeX] = 'plain';
            }
        }
    }
}

function renderMap() {
    gameBoard.innerHTML = '';
    for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.classList.add('cell', grid[y][x]);
            cell.dataset.x = x;
            cell.dataset.y = y;
            cell.addEventListener('click', handleCellClick);
            gameBoard.appendChild(cell);
        }
    }
}

function handleCellClick(event) {
    if (isPlacingTower) {
        const x = parseInt(event.target.dataset.x);
        const y = parseInt(event.target.dataset.y);
        if (grid[y][x] === 'plain') {
            placeTower(x, y);
            isPlacingTower = false;
        }
    }
}

function placeTower(x, y) {
    grid[y][x] = 'tower-base';
    towers.push({ x, y });
    renderMap();
    const towerElement = document.createElement('div');
    towerElement.classList.add('tower');
    gameBoard.children[y * GRID_WIDTH + x].appendChild(towerElement);
}

function spawnEnemy() {
    const startY = Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1;
    const enemy = {
        x: 0,
        y: startY,
        health: 100,
        element: document.createElement('div'),
        moveProgress: 0
    };
    enemy.element.classList.add('enemy');
    enemy.element.style.position = 'absolute';
    enemy.element.style.left = '0%';
    enemy.element.style.top = `${startY * (100 / GRID_HEIGHT)}%`;
    enemy.element.style.width = `${100 / GRID_WIDTH}%`;
    enemy.element.style.height = `${100 / GRID_HEIGHT}%`;
    gameBoard.appendChild(enemy.element);
    enemies.push(enemy);
}

function moveEnemies() {
    enemies.forEach((enemy, index) => {
        const path = findPath(enemy.x, enemy.y, GRID_WIDTH - 1, enemy.y);
        if (path && path.length > 1) {
            const terrainType = grid[enemy.y][enemy.x];
            enemy.moveProgress += 0.05 * terrainTypes[terrainType].speedMultiplier;
            if (enemy.moveProgress >= 1) {
                const nextStep = path[1];
                enemy.x = nextStep.x;
                enemy.y = nextStep.y;
                enemy.element.style.transition = 'all 0.5s';
                enemy.element.style.left = `${enemy.x * (100 / GRID_WIDTH)}%`;
                enemy.element.style.top = `${enemy.y * (100 / GRID_HEIGHT)}%`;
                enemy.moveProgress = 0;
            }
        }

        if (enemy.x === GRID_WIDTH - 1) {
            playerHealth -= 10;
            playerHealthDisplay.textContent = playerHealth;
            enemy.element.remove();
            enemies.splice(index, 1);
        }
    });
}

function findPath(startX, startY, endX, endY) {
    const openSet = [];
    const closedSet = new Set();
    const start = { x: startX, y: startY, g: 0, h: 0, f: 0, parent: null };
    openSet.push(start);

    while (openSet.length > 0) {
        let current = openSet[0];
        let currentIndex = 0;
        for (let i = 1; i < openSet.length; i++) {
            if (openSet[i].f < current.f) {
                current = openSet[i];
                currentIndex = i;
            }
        }

        if (current.x === endX && current.y === endY) {
            let path = [];
            while (current) {
                path.push({ x: current.x, y: current.y });
                current = current.parent;
            }
            return path.reverse();
        }

        openSet.splice(currentIndex, 1);
        closedSet.add(`${current.x},${current.y}`);

        const neighbors = [
            { x: current.x + 1, y: current.y },
            { x: current.x - 1, y: current.y },
            { x: current.x, y: current.y + 1 },
            { x: current.x, y: current.y - 1 }
        ];

        for (let neighbor of neighbors) {
            if (neighbor.x < 0 || neighbor.x >= GRID_WIDTH || neighbor.y < 0 || neighbor.y >= GRID_HEIGHT ||
                grid[neighbor.y][neighbor.x] === 'water' || grid[neighbor.y][neighbor.x] === 'wall' ||
                closedSet.has(`${neighbor.x},${neighbor.y}`)) {
                continue;
            }

            const terrainType = grid[neighbor.y][neighbor.x];
            const movementCost = 1 / terrainTypes[terrainType].speedMultiplier;
            const gScore = current.g + movementCost;
            const hScore = Math.abs(neighbor.x - endX) + Math.abs(neighbor.y - endY);
            const fScore = gScore + hScore;

            const existingNeighbor = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
            if (!existingNeighbor || gScore < existingNeighbor.g) {
                if (!existingNeighbor) {
                    openSet.push({ x: neighbor.x, y: neighbor.y, g: gScore, h: hScore, f: fScore, parent: current });
                } else {
                    existingNeighbor.g = gScore;
                    existingNeighbor.f = fScore;
                    existingNeighbor.parent = current;
                }
            }
        }
    }

    return null;
}

function startWave() {
    currentWave++;
    waveCounterDisplay.textContent = currentWave;
    waveTimer = 60;
    waveTimerDisplay.textContent = waveTimer;
    waveInterval = setInterval(() => {
        waveTimer--;
        waveTimerDisplay.textContent = waveTimer;
        if (waveTimer <= 0 || enemies.length === 0) {
            clearInterval(waveInterval);
            if (currentWave < 5) {  // 5ウェーブで終了
                startWaveButton.disabled = false;
            } else {
                alert('ゲームクリア！');
            }
        }
    }, 1000);

    for (let i = 0; i < 5 + currentWave; i++) {
        setTimeout(spawnEnemy, i * 2000);
    }
}

function gameLoop() {
    moveEnemies();
    if (playerHealth <= 0) {
        alert('ゲームオーバー！');
        return;
    }
    requestAnimationFrame(gameLoop);
}

// イベントリスナー
startWaveButton.addEventListener('click', () => {
    startWave();
    startWaveButton.disabled = true;
});

addTowerButton.addEventListener('click', () => {
    isPlacingTower = true;
});

document.getElementById('plain-map').addEventListener('click', () => initializeMap('plain'));
document.getElementById('river-map').addEventListener('click', () => initializeMap('river'));
document.getElementById('mountain-map').addEventListener('click', () => initializeMap('mountain'));

// ゲーム初期化
initializeMap('plain');
gameLoop();
    </script>
</body>
</html>
